'\" t
.\"     Title: sssd-secrets
.\"    Author: Основна гілка розробки SSSD \(em https://pagure.io/SSSD/sssd/
.\" Generator: DocBook XSL Stylesheets vsnapshot <http://docbook.sf.net/>
.\"      Date: 12/09/2020
.\"    Manual: Формати файлів та правила
.\"    Source: SSSD
.\"  Language: English
.\"
.TH "SSSD\-SECRETS" "5" "12/09/2020" "SSSD" "Формати файлів та правила"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
sssd-secrets \- Відповідач реєстраційних даних SSSD
.SH "ОПИС"
.PP
На цій сторінці довідника описано налаштування засобу надання відповідей Secrets для
\fBsssd\fR(8)\&. Щоб дізнатися більше про синтаксис налаштування, зверніться до розділу \(FoФОРМАТ ФАЙЛІВ\(Fc сторінки довідника
\fBsssd.conf\fR(5)\&.
.PP
У багатьох програмах системи або користувача існує потреба у збереженні конфіденційних даних, зокрема паролів і ключів до служб, та зручній роботі з цими даними\&. Простим способом вирішення цієї проблеми є вбудовування цих
\(lqреєстраційних даних\(rq
до файлів налаштувань\&. Втім, це призводить до потенційного розширення доступу до конфіденційних даних через резервні копії, системи керування налаштуваннями, та загалом робить захист даних важчим\&.
.PP
Проєкт
\m[blue]\fBcustodia\fR\m[]\&\s-2\u[1]\d\s+2
було створено для урегулювання цієї проблеми у хмароподібних середовищах, але нам ця ідея здалася вартою уваги навіть на рівні окремої ізольованої системи\&. Як служба захисту, SSSD є ідеальним місцем для реалізації такої можливості з доступом до відповідного програмного інтерфейсу через сокети UNIX\&. Така реалізація уможливлює використання локальних викликів і належну маршрутизацію до локального або віддаленого сховища ключів, зокрема сховища IPA, для зберігання, депонування і відновлення даних\&.
.PP
Записи реєстраційних даних є простими парами ключ\-значення\&. Реєстраційні дані кожного з користувачів співвідносяться із його простором назв на основі ідентифікатора користувача\&. Це означає, що реєстраційні дані одного користувача ніколи не потраплять до іншого\&. Реєстраційні дані зберігаються у
\(lqконтейнерах\(rq, які можна вкладати один у одного\&.
.PP
Оскільки відповідач реєстраційних даних може використовуватися ззовні для зберігання загальних реєстраційних даних, як це описано у решті цієї сторінки підручника, і всередині іншими компонентами SSSD для зберігання власних реєстраційних даних, можна налаштувати деякі параметри, зокрема квоти для окремих записів
\(lqhive\(rq
у підрозділі налаштувань із назвою відповідного рою\&. Підтримувані у поточній версії рої:
.PP
secrets
.RS 4
записи реєстраційних даних для загального використання
.RE
.PP
kcm
.RS 4
використовується службою
\fBsssd-kcm\fR(8)\&.
.RE
.SH "КОРИСТУВАННЯ ВІДПОВІДАЧЕМ РЕЄСТРАЦІЙНИХ ДАНИХ"
.PP
Сокет UNIX, на якому відповідач SSSD очікує на дані, розташовано у
/var/run/secrets\&.socket\&.
.PP
Відповідач для реєстраційних даних активується за допомогою сокетів
\fBsystemd\fR(1)\&. На відміну від інших відповідачів SSSD, його не можна запустити додаванням рядка
\(lqsecrets\(rq
до інструкції
\(lqservice\(rq\&. Модуль сокета systemd називається
\(lqsssd\-secrets\&.socket\(rq, а відповідний файл служби має назву
\(lqsssd\-secrets\&.service\(rq\&. Щоб службу можна було активувати за допомогою сокета, слід увімкнути і задіяти сокет, а потім увімкнути службу:
.sp
.if n \{\
.RS 4
.\}
.nf
systemctl start sssd\-secrets\&.socket
systemctl enable sssd\-secrets\&.socket
systemctl enable sssd\-secrets\&.service
            
.fi
.if n \{\
.RE
.\}
.sp
Будь ласка, зауважте, що відповідні налаштування модулів вже могло бути виконано засобами вашого дистрибутива\&.
.SH "ПАРАМЕТРИ НАЛАШТУВАННЯ"
.PP
Відповідачу реєстраційних даних можна передавати типові параметри відповідача SSSD, зокрема
\(lqdebug_level\(rq
та
\(lqfd_limit\(rq\&. Із повним списком параметрів можна ознайомитися на сторінці підручника
\fBsssd.conf\fR(5)\&. Крім того, передбачено декілька специфічних для реєстраційних даних параметрів\&.
.PP
Відповідач реєстраційних даних налаштовується за допомогою загального розділу
\(lq[secrets]\(rq
і необов\*(Aqязкових розділів
\(lq[secrets/users/$uid]\(rq
для окремих користувачів у
sssd\&.conf\&. Будь ласка, зауважте, що деякі параметра, зокрема тип постачальника даних, можна вказати лише у підрозділах окремих користувачів\&.
.PP
provider (рядок)
.RS 4
Цей параметр визначає, де слід зберігати реєстраційні дані\&. Відповідач реєстраційних даних може налаштувати підрозділи для окремих користувачів (наприклад,
\(lq[secrets/users/123]\(rq
\(em див\&. нижню частину цієї сторінки підручників, де наведено повний приклад використання Custodia для окремого користувача), які визначатимуть, яке сховище відповідача зберігатиме дані певного користувача\&. Підрозділи окремих користувачів мають містити усі параметри відповідного засобу надання даних користувача\&. Будь ласка, зауважте, що у поточній версії загальний постачальних даних з завжди локальним, а проміжного постачальника можна вказати лише для окремого користувача у відповідному розділі\&. Передбачено підтримку таких відповідачів:
.PP
local
.RS 4
Реєстраційні дані зберігаються у локальній базі даних, зашифровані, разом із іншими даними, за допомогою основного ключа\&. Для локального засобу надання даних у поточній версії не передбачено жодних додаткових параметрів\&.
.RE
.PP
proxy
.RS 4
Відповідач реєстраційних даних переспрямовує запити до сервера Custodia\&. Для засобу надання даних \(Foproxy\(Fc передбачено декілька додаткових параметрів (див\&. нижче)\&.
.RE
.sp
Типове значення: local
.RE
.PP
Наведені нижче параметри стосуються лише записів реєстраційних даних
\(lqhive\(rq
і тому їх слід встановлювати у підрозділах окремих роїв\&. Встановлення значення параметра 0 означає \(Foбез обмежень\(Fc\&.
.PP
containers_nest_level (ціле значення)
.RS 4
Цей параметр визначає максимальну дозволену кількість вкладених контейнерів\&.
.sp
Типове значення: 4
.RE
.PP
max_secrets (ціле значення)
.RS 4
Цей параметр визначає максимальну кількість записів реєстраційних даних, які можна зберігати у рою\&.
.sp
Типове значення: 1024 (рій реєстраційних даних), 256 (рій kcm)
.RE
.PP
max_uid_secrets (ціле число)
.RS 4
Цей параметр визначає максимальну кількість записів реєстраційних даних, які можна зберігати окремо для різних UID у рою\&.
.sp
Типове значення: 256 (рій реєстраційних даних), 64 (рій kcm)
.RE
.PP
max_payload_size (ціле значення)
.RS 4
Цей параметри визначає максимальний об\*(Aqєм даних для реєстраційного запису у кілобайтах\&.
.sp
Типове значення: 16 (рій реєстраційних даних), 65536 (64 МіБ) (рій kcm)
.RE
.PP
Наприклад, щоб встановити різні квоти для роїв
\(lqsecrets\(rq
та
\(lqkcm\(rq, скористайтеся такими рядками:
.sp
.if n \{\
.RS 4
.\}
.nf
[secrets/secrets]
max_payload_size = 128

[secrets/kcm]
max_payload_size = 256
            
.fi
.if n \{\
.RE
.\}
.PP
Вказані нижче параметри стосуються лише конфігурацій, у яких використовується засіб надання даних
\(lqproxy\(rq\&.
.PP
proxy_url (рядок)
.RS 4
Адреса, за якою очікуватиме на дані сервер Custodia\&. У поточній версії передбачено підтримку протоколів http і https\&.
.sp
Формат адреси має відповідати формату, що визначається RFC 2732:
.sp
http[s]://<вузол>[:порт]
.sp
Приклад: http://localhost:8080
.RE
.PP
auth_type (рядок)
.RS 4
Спосіб розпізнавання сервером Custodia\&. Передбачено підтримку таких способів розпізнавання:
.PP
basic_auth
.RS 4
Виконати розпізнавання на основі імені користувача і пароля, які визначено параметрами
\(lqusername\(rq
і
\(lqpassword\(rq\&.
.RE
.PP
header
.RS 4
Виконати розпізнавання за допомогою значення заголовка HTTP, як його визначено у параметрах налаштування
\(lqauth_header_name\(rq
і
\(lqauth_header_value\(rq\&.
.RE
.RE
.PP
auth_header_name (рядок)
.RS 4
Якщо встановлено, відповідач реєстраційних даних додаватиме заголовок із цією назвою до запиту HTTP разом із значенням, яке визначається параметром налаштування
\(lqauth_header_value\(rq\&.
.sp
Приклад: MYSECRETNAME
.RE
.PP
auth_header_value (рядок)
.RS 4
Значення, яке sssd\-secrets має використовувати для
\(lqauth_header_name\(rq\&.
.sp
Приклад: mysecret
.RE
.PP
forward_headers (список рядків)
.RS 4
Список заголовків HTTP, які слід переспрямувати до сервера Custodia разом із запитом\&.
.sp
Типове значення: not set
.RE
.PP
verify_peer (булеве значення)
.RS 4
Визначає, чи слід перевіряти сертифікат вузла і чи слід вважати його чинним, якщо для засобу надання даних проксі використано протокол HTTPS\&.
.sp
Типове значення: true
.RE
.PP
verify_host (булеве значення)
.RS 4
Визначає, чи має назва вузла збігатися із назвою вузла у його сертифікаті, якщо для засобу надання даних проксі використано протокол HTTPS\&.
.sp
Типове значення: true
.RE
.PP
capath (рядок)
.RS 4
Шлях до каталогу, у якому зберігаються сертифікати служб сертифікації\&. Якщо для цього параметра не встановлено значення, використовуватиметься загальносистемний типовий шлях\&.
.sp
Типове значення: not set
.RE
.PP
cacert (рядок)
.RS 4
Шлях до файла, у якому міститься сертифікат служби сертифікації сервера\&. Якщо для цього параметра не встановлено значення, програма шукатиме сертифікат CA у
\(lqcapath\(rq\&.
.sp
Типове значення: not set
.RE
.PP
cert (рядок)
.RS 4
Шлях до файла, що містить клієнтський сертифікат, якщо такий потрібен для сервера\&. Цей файл може також містити закритий ключ\&. Закритий ключ можна також зберігати у файлі, назву якого встановлено за допомогою параметра
\(lqkey\(rq\&.
.sp
Типове значення: not set
.RE
.PP
key (рядок)
.RS 4
Шлях до файла, у якому міститься закритий ключ клієнта\&.
.sp
Типове значення: not set
.RE
.SH "КОРИСТУВАННЯ API REST"
.PP
У цьому розділі наведено список доступних команд та приклади користування із використанням програми
\fBcurl\fR(1)\&. Усі запити до засобу надання даних проксі мають встановлювати для заголовка Content Type значення
\(lqapplication/json\(rq\&. Крім того, для локального засобу надання даних передбачено підтримку встановлення для Content Type значення
\(lqapplication/octet\-stream\(rq\&. Реєстраційні дані, збережені із запитами, де встановлено значення заголовка Content Type
\(lqapplication/octet\-stream\(rq, є даними у кодуванні base64 у сховищі, які розшифровуються під час отримання, тому не можна зберігати реєстраційні дані із одним значенням Content Type і отримувати з іншим\&. Адреса реєстраційних даних має починатися з
/secrets/\&.
.PP
Отримання списку реєстраційних даних
.RS 4
Щоб отримати список доступних реєстраційних даних, надішліть запит HTTP GET із кінцевою навскісною рискою у шляху до контейнера\&.
.sp
Приклад:
.sp
.if n \{\
.RS 4
.\}
.nf
curl \-H "Content\-Type: application/json" \e
     \-\-unix\-socket /var/run/secrets\&.socket \e
     \-XGET http://localhost/secrets/
                        
.fi
.if n \{\
.RE
.\}
.sp
.RE
.PP
Отримання реєстраційних даних
.RS 4
Щоб прочитати значення окремого запису реєстраційних даних, надішліть запит HTTP GET без кінцевої навскісної риски\&. Остання частина адреси вважатиметься назвою запису реєстраційних даних\&.
.sp
Приклади:
.sp
.if n \{\
.RS 4
.\}
.nf
curl \-H "Content\-Type: application/json" \e
     \-\-unix\-socket /var/run/secrets\&.socket \e
     \-XGET http://localhost/secrets/foo
                        
.fi
.if n \{\
.RE
.\}
.sp

.sp
.if n \{\
.RS 4
.\}
.nf
curl \-H "Content\-Type: application/octet\-stream" \e
     \-\-unix\-socket /var/run/secrets\&.socket \e
     \-XGET http://localhost/secrets/bar
                        
.fi
.if n \{\
.RE
.\}
.sp
.RE
.PP
Встановлення реєстраційних даних
.RS 4
Щоб встановити запис реєстраційних даних з використанням типу
\(lqapplication/json\(rq, надішліть запит HTTP PUT із даними JSON, які включатимуть тип і значення\&. Тип (type) має бути встановлено у значення "simple", а значення (value) має містити дані реєстраційного запису\&. Якщо запис із вказаною назвою вже існує, відповіддю буде повідомлення про помилку 409 HTTP\&.
.sp
Тип
\(lqapplication/json\(rq
просто надсилає реєстраційний ключ як вміст повідомлення\&.
.sp
У наведеному нижче прикладі ми встановлюємо для реєстраційних даних із назвою \(Fofoo\(Fc значення \(Fofoosecret\(Fc, а для реєстраційних даних із назвою \(Fobar\(Fc \(em значення \(Fobarsecret\(Fc, використовуючи різні значення Content Type\&.
.sp
.if n \{\
.RS 4
.\}
.nf
curl \-H "Content\-Type: application/json" \e
     \-\-unix\-socket /var/run/secrets\&.socket \e
     \-XPUT http://localhost/secrets/foo \e
     \-d\*(Aq{"type":"simple","value":"foosecret"}\*(Aq
                        
.fi
.if n \{\
.RE
.\}
.sp

.sp
.if n \{\
.RS 4
.\}
.nf
curl \-H "Content\-Type: application/octet\-stream" \e
     \-\-unix\-socket /var/run/secrets\&.socket \e
     \-XPUT http://localhost/secrets/bar \e
     \-d\*(Aqbarsecret\*(Aq
                        
.fi
.if n \{\
.RE
.\}
.sp
.RE
.PP
Створення контейнера
.RS 4
Контейнери надають додатковий простір назв для реєстраційних даних цього користувача\&. Для створення контейнера надішліть запит HTTP POST, чи я адреса завершуватиметься назвою контейнера\&. Будь ласка, зауважте, що адреса має завершуватися символом навскісної риски\&.
.sp
У наступному прикладі створюємо контейнер із назвою \(Fomycontainer\(Fc:
.sp
.if n \{\
.RS 4
.\}
.nf
curl \-H "Content\-Type: application/json" \e
     \-\-unix\-socket /var/run/secrets\&.socket \e
     \-XPOST http://localhost/secrets/mycontainer/
                        
.fi
.if n \{\
.RE
.\}
.sp
Щоб працювати із записами реєстраційних даних у цьому контейнері, просто вкладіть записи реєстраційних даних до шляху контейнера:
.sp
.if n \{\
.RS 4
.\}
.nf
http://localhost/secrets/mycontainer/mysecret
                        
.fi
.if n \{\
.RE
.\}
.sp
.RE
.PP
Вилучення реєстраційних даних або контейнера
.RS 4
Щоб вилучити запис реєстраційних даних або контейнер, надішліть запит HTTP DELETE із шляхом до запису реєстраційних даних або до контейнера\&.
.sp
У наведеному нижче прикладі ми вилучимо реєстраційні дані для запису \(Fofoo\(Fc\&.
.sp
.if n \{\
.RS 4
.\}
.nf
curl \-H "Content\-Type: application/json" \e
     \-\-unix\-socket /var/run/secrets\&.socket \e
     \-XDELETE http://localhost/secrets/foo
                        
.fi
.if n \{\
.RE
.\}
.sp
.RE
.SH "ПРИКЛАД НАЛАШТОВУВАННЯ МОДУЛІВ НАДАННЯ ДАНИХ CUSTODIA І ПРОКСІ"
.PP
Для тестування засобу надання даних \(Foproxy\(Fc вам слід налаштувати проксі\-передавання на сервер Custodia\&. Будь ласка, завжди користуйтеся документацією до Custodia, оскільки інструкції налаштовування у різних версіях Custodia можуть бути різними\&.
.PP
Ці налаштування визначають для сервера Custodia адресу очікування даних http://localhost:8080, дозволяють будь\-кому із заголовком із назвою MYSECRETNAME, який встановлено у значення mysecretkey, обмін даними із сервером Custodia\&. Запишіть ці дані до файла (наприклад,
\fIcustodia\&.conf\fR):
.sp
.if n \{\
.RS 4
.\}
.nf
[global]
server_version = "Secret/0\&.0\&.7"
server_url = http://localhost:8080/
auditlog = /var/log/custodia\&.log
debug = True

[store:simple]
handler = custodia\&.store\&.sqlite\&.SqliteStore
dburi = /var/lib/custodia\&.db
table = secrets

[auth:header]
handler = custodia\&.httpd\&.authenticators\&.SimpleHeaderAuth
header = MYSECRETNAME
value = mysecretkey

[authz:paths]
handler = custodia\&.httpd\&.authorizers\&.SimplePathAuthz
paths = /secrets

[/]
handler = custodia\&.root\&.Root
store = simple
            
.fi
.if n \{\
.RE
.\}
.PP
Далі, віддайте команду
\fIcustodia\fR, вказавши файл налаштувань у параметрі командного рядка\&.
.PP
Будь ласка, зверніть увагу на те, що у поточній версії неможливо на загальному рівні переспрямовувати усі запити до екземпляра Custodia\&. Замість цього слід визначати підрозділи для окремих ідентифікаторів користувачів, які переспрямовуватимуть запити до Custodia\&. У наведеному нижче прикладі проілюстровано конфігурацію, за якої запити користувача із UID 123 переспрямовуватимуться до Custodia, а запити усіх інших користувачів оброблятимуться локальним засобом надання даних\&.
.sp
.if n \{\
.RS 4
.\}
.nf
[secrets]

[secrets/users/123]
provider = proxy
proxy_url = http://localhost:8080/secrets/
auth_type = header
auth_header_name = MYSECRETNAME
auth_header_value = mysecretkey
        
.fi
.if n \{\
.RE
.\}
.SH "AUTHORS"
.PP
\fBОсновна гілка розробки SSSD \(em
https://pagure\&.io/SSSD/sssd/\fR
.SH "NOTES"
.IP " 1." 4
custodia
.RS 4
\%https://github.com/latchset/custodia
.RE
